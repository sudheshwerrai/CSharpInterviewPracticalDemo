



1. is Operator
Purpose: Checks if an object is compatible with a given type.
Return type: bool (true or false).
Safe type checking: It doesn’t throw exception, only returns true/false.


2. as Operator
Purpose: Converts (casts) an object to a given type safely.
Return type: Returns the object if cast is valid; otherwise null.
Important: Works only with reference types and nullable types, not with 
value types (like int, double etc.).

-------------------------------------------------------------------------------









Dynamic Keyword In C#

1.Introduced in C# 4.0. -Done
2.Type is decided at runtime. -Done
3.No compile - time checking, only runtime binding. -Done
4.Can call members(methods/ properties) not known at compile time. -Done
5.Throws RuntimeBinderException if the member doesn’t exist. - Done
6.Similar to `object`, but no explicit casting is needed.-Done
7. Supports implicit conversions. -Done
8. Can store null at declaration. - Done
9. Can be used as a method parameter or return type. - Done
10. Same variable can hold different types of values. - Done
11. No IntelliSense support. - Done
12. Slower performance due to late binding. - Done
13. Provides flexibility over type safety. - Done
----------------------------------------------------------------------------------------
Destructor In C#

1. What is a Destructor in C#?
A destructor is a special method in a class that is automatically called 
when the object is about to be destroyed by the Garbage Collector (GC).
It’s used to release unmanaged resources (files, database connections, etc.)
before the object is removed from memory.

2. Why use a Destructor?
C# automatically manages memory for most things, but unmanaged resources 
(like file handles, network sockets, database connections) need manual 
cleanup to avoid memory leaks. A destructor is your last chance to clean up 
these resources.

3. When to use a Destructor? Use it only when:
You are working with unmanaged resources (file streams, OS handles, 
database connections, etc.).You want a safety net in case the developer 
forgot to call Dispose().
⚠️ Note: Overusing destructors can slow down garbage collection. If possible,
implement IDisposable instead.

4. How to use a Destructor in C#?
Syntax: ~ClassName()

No access modifiers, no parameters, and you cannot call it manually.
Runs automatically before garbage collection destroys the object.